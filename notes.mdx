INDEX:
1. user
2. product
3. employee
4. category
5. student
6. customer
7. myname
8. common
9. guards
10. myname
11. user-roles
12. filter/http-exception
13. exception
14. guards
15. middleware
16. database

1. npm i -g @nestjs/cli ->one time global installation
2. nest new <project-name> -> create a new nestjs project
3. cd <project-name> -> navigate to the project directory
4. i selected npm as the package manager,so run "npm run start:devc" to start the development server
5. now to create a new controller, run "nest g controller <controller-name>"
6. now to create a new service, run "nest g service <service-name>"
7. service is used to write the business logic of the application,they always will have @Injectable() decorator to make it usable/Injectable in the controller
8. now to create a new module, run "nest g module <module-name>"

dependency injection from service to controller
1. we can inject the service into the controller using the constructor
## Constructor explanation
**Line 6:**
```typescript
constructor(private readonly productService: ProductService){}
```

### What it does
This uses NestJS dependency injection (DI) to provide `ProductService` to the controller.

### Syntax breakdown

1. `constructor(...)`
   - Runs when the controller is created.

2. `private readonly productService`
   - `private`: Only accessible inside this class.
   - `readonly`: Cannot be reassigned after initialization.
   - `productService`: The property name.

3. `: ProductService`
   - Type annotation: must be a `ProductService` instance.

### TypeScript shorthand
This is shorthand for:
```typescript
export class ProductController {
    private readonly productService: ProductService;
    
    constructor(productService: ProductService) {
        this.productService = productService;
    }
}
```

### Why NestJS uses this pattern
- Dependency injection: NestJS creates and provides the service instance.
- Testability: Easy to mock the service in tests.
- Loose coupling: The controller depends on the interface, not the implementation.
- Automatic wiring: NestJS resolves dependencies when the controller is created.

### How it works
1. NestJS sees `ProductService` in the constructor.
2. It checks if `ProductService` is provided in the module.
3. It creates or reuses an instance.
4. It passes that instance to the constructor.
5. The controller can use `this.productService` in its methods.

### In your code
- Line 9: `this.productService.getAllProducts()` uses the injected service.
- Line 15: `this.productService.getProductById(...)` uses it again.

### 1. "This class" = ProductController

When I said "Only accessible inside this class", I meant the ProductController class (the file with the constructor).

```typescript
export class ProductController {  // ← THIS is "this class"
    constructor(private readonly productService: ProductService){}
    // productService can only be used inside ProductController
}
```

So `productService` is a property of ProductController, not ProductService.

---

### 2. What is `productService`?

`productService` is an instance (object) of the `ProductService` class.

Think of it like this:
- `ProductService` = the blueprint/class
- `productService` = an actual object created from that blueprint

It's like:
- `Car` = the class/blueprint
- `myCar` = an actual car object

---

### 3. Why use the constructor?

The constructor receives the `ProductService` instance that NestJS creates and provides.

Here's what happens behind the scenes:

```typescript
// Step 1: NestJS creates an instance of ProductService
const serviceInstance = new ProductService();
// This creates: { products: [...], getAllProducts: function, getProductById: function }

// Step 2: NestJS creates ProductController and passes the service
const controller = new ProductController(serviceInstance);
// Now controller.productService = serviceInstance

// Step 3: When you call controller.getProducts(), it uses:
controller.productService.getAllProducts()  // ← Uses the injected instance
```

---

### 4. Visual breakdown

```typescript
export class ProductController {
    // This line does THREE things at once:
    constructor(private readonly productService: ProductService){}
    
    // 1. Declares a property: productService
    // 2. Makes it private (only usable in ProductController)
    // 3. Makes it readonly (can't change it later)
    // 4. Receives the ProductService instance from NestJS
}
```

Equivalent to writing:
```typescript
export class ProductController {
    private readonly productService: ProductService;  // Property declaration
    
    constructor(productService: ProductService) {     // Constructor receives it
        this.productService = productService;         // Assigns it
    }
}
```

---

### 5. The flow

1. NestJS sees `ProductService` in the constructor.
2. NestJS creates an instance: `new ProductService()` → gives you an object with `products`, `getAllProducts()`, `getProductById()`.
3. NestJS passes that instance to the constructor.
4. The constructor stores it in `this.productService`.
5. You can use `this.productService.getAllProducts()` anywhere in ProductController.

---

### Summary

- "This class" = ProductController (where the constructor lives)
- `productService` = an instance/object of the ProductService class
- Constructor = receives the instance from NestJS and stores it
- `private` = only ProductController can use `productService`
- `readonly` = you can't reassign `productService` later

When you write `this.productService.getAllProducts()`, you're calling a method on the injected ProductService instance.



DEPENDENCY INJECTION:
It is a mechanism where the framework automatically provides the required dependencies into the without creating them manually.
- makes the codes reusable and readable.
- promotes loose coupling.
- 


DATA TRANSFER OBJECT(DTO):
-  an object carries data between layers(from client to backend)
- it is used to define the shape of the incoming data.
- ensures only required data is passed(security+validation)

INTERFACE:
- define the structure(type) of an object.
- help write cleaner and type-safe code.
- used for both request(DTO's) and esponse objects.


## validation pipe:
```typescript
  app.useGlobalPipes(new ValidationPipe({
    whitelist: true,
    forbidNonWhitelisted: true
  }))
  ```
  - whitelist: true -> removes extra properties that are not in the DTO
  - forbidNonWhitelisted: true -> returns a 400 error if extra properties are sent
## Explanation of ValidationPipe

**Lines 6-9:**
```typescript
app.useGlobalPipes(new ValidationPipe({
  whitelist: true,
  forbidNonWhitelisted: true
}))
```

### What is ValidationPipe?
`ValidationPipe` automatically validates incoming request data using your DTOs (Data Transfer Objects).

### What does `useGlobalPipes` do?
It applies this validation to all routes in your app, so you don't need to add it to each controller.

---

### The two options explained

#### 1. `whitelist: true`
- Strips properties that are not in your DTO.
- Extra properties are removed; only DTO properties remain.

Example with your `CreateCustomerDto`:
```typescript
// Your DTO only has: name, age
export class CreateCustomerDto {
  name: string;
  age: number;
}
```

Request sent:
```json
{
  "name": "John",
  "age": 25,
  "hackerField": "malicious data",  // ← Not in DTO
  "email": "test@test.com"          // ← Not in DTO
}
```

With `whitelist: true`, the controller receives:
```json
{
  "name": "John",
  "age": 25
}
```
The extra fields are removed.

---

#### 2. `forbidNonWhitelisted: true`
- Returns a 400 error if extra properties are sent.
- Stops the request instead of silently removing fields.

Same request:
```json
{
  "name": "John",
  "age": 25,
  "hackerField": "malicious data"  // ← Extra field
}
```

Response:
```json
{
  "statusCode": 400,
  "message": [
    "property hackerField should not exist"
  ],
  "error": "Bad Request"
}
```

---

### Why use both together?
- `whitelist: true` removes extra fields.
- `forbidNonWhitelisted: true` rejects requests with extra fields.

This enforces strict validation: only the exact properties in your DTO are allowed.

---

### Real-world example

Your `CreateCustomerDto`:
```typescript
export class CreateCustomerDto {
  @IsString()
  name: string;
  
  @IsInt()
  age: number;
}
```

Valid request:
```json
{
  "name": "John",
  "age": 25
}
```
Result: Accepted.

Invalid request (extra field):
```json
{
  "name": "John",
  "age": 25,
  "email": "john@example.com"  // ← Not in DTO!
}
```
Result: 400 error — "property email should not exist"

Invalid request (wrong type):
```json
{
  "name": "John",
  "age": "twenty-five"  // ← Should be number!
}
```
Result: 400 error — "age must be an integer number"

---

### Summary
- `ValidationPipe`: Validates request data automatically.
- `whitelist: true`: Removes properties not in your DTO.
- `forbidNonWhitelisted: true`: Rejects requests with extra properties.
- Together: Enforces strict validation across your app.

This helps prevent:
- Security issues (unexpected data)
- Bugs (typos in field names)
- Data corruption (wrong data types)

Your API only accepts the exact data structure you define in your DTOs.



- pipes are used to transform or validate the data in the request body,query params,headers,etc.
- a pipe runs before the data hits the route handler(controller method).
- you can apply pipes at method level,controller level, or globally at the app level.

for creating a new pipe, run "nest g pipe <pipe-name>"

## What are Pipes?

Pipes transform or validate data before it reaches your controller method. They run between the request and your handler.

Think of pipes as filters/transformers:
- Transform data (e.g., convert to uppercase, parse numbers)
- Validate data (e.g., check if email is valid)
- Provide default values

---

## How Pipes Work in Your Code

### Your `myname.controller.ts`:

```typescript
@Post('custom')
transformName(@Body('name', new UppercasePipe()) name: string){
    return {message: `Received name: ${name}`}
}
```

Line 8 breakdown:
- `@Body('name', ...)` — extracts the `name` field from the request body
- `new UppercasePipe()` — creates a pipe instance to transform the value
- `name: string` — the transformed value received by the method

---

## Your Custom Pipe: `UppercasePipe`

```typescript
export class UppercasePipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    if(typeof value === 'string') {
      return value.toUpperCase();
    }
    return value;
  }
}
```

What it does:
1. Implements `PipeTransform` (required interface)
2. `transform()` receives the input value
3. If it's a string, converts it to uppercase
4. Returns the transformed value

---

## How It Works in Practice

### Example Request:
```json
POST /myname/custom
{
  "name": "john doe"
}
```

### Flow:
1. Request arrives with `"name": "john doe"`
2. `@Body('name', new UppercasePipe())` extracts `"john doe"`
3. `UppercasePipe.transform()` converts it to `"JOHN DOE"`
4. Your method receives `name = "JOHN DOE"`
5. Response: `{message: "Received name: JOHN DOE"}`

---

## Visual Flow Diagram

```
Request: {"name": "john doe"}
    ↓
@Body('name', new UppercasePipe())
    ↓
UppercasePipe.transform("john doe")
    ↓
Returns: "JOHN DOE"
    ↓
transformName(name: string) receives "JOHN DOE"
    ↓
Response: {"message": "Received name: JOHN DOE"}
```

---

## Why Use Pipes Here?

- Data normalization: ensures consistent casing
- Separation of concerns: transformation logic is separate from business logic
- Reusability: can be used in other controllers
- Clean code: controller stays focused on handling requests

---

## Other Common Pipe Examples

### 1. ParseIntPipe (Built-in)
```typescript
@Get(':id')
getUser(@Param('id', ParseIntPipe) id: number) {
  // Converts string "123" → number 123
}
```

### 2. ValidationPipe (Built-in)
```typescript
@Post()
createUser(@Body(ValidationPipe) dto: CreateUserDto) {
  // Validates data against DTO rules
}
```

### 3. Custom ParseNumberPipe
```typescript
transform(value: string) {
  return Number(value); // "42" → 42
}
```

---

## Summary

- Pipes transform or validate data before it reaches your controller
- In your code: `UppercasePipe` converts the name to uppercase
- Usage: `@Body('name', new UppercasePipe())` applies the pipe to the `name` field
- Result: `"john doe"` becomes `"JOHN DOE"` before your method receives it

Pipes are middleware for your data — they process it before you use it.



GUARDS:
- guards are classes that implement logic to decide whether a req is allowed or not.
- They implement the CanActivate interface and run before the route handler.
- mostly use for authentication and authorization.

nest g guard guards/auth



exception filters:
- handles errors that occur during request processing.
- can be used to return a custom response to the client.
- can be used to log the error.
- can be used to return a 500 error.

nest g filter filters/http-exception

guards vs middleware:

middleware:
- before controller is called.
- logging incoming requests.
- authentication tokens.
- request transformations(eg convert string to numbers)
- blocking and redirecting requests.
- setting headers.
nest g middleware middleware/logger

Guard:
- before route is accessed based on auth.
- used for authorization.(role check,access allowed?)


*** study consumer.apply().() in the app.module.ts and Life Cycle Hooks in Nest JS | onModuleInit & onAppShutdown



for environment variables, run following installation command:
npm i @nestjs/config

ConfigModule.forRoot({
    isGlobal: true,}) -> makes the config module available globally to all modules in the application in app.module file.
    -> this is used to load environment variables from the .env file.